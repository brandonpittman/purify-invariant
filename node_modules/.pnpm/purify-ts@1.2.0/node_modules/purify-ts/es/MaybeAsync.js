"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaybeAsync = void 0;
const Maybe_1 = require("./Maybe");
const EitherAsync_1 = require("./EitherAsync");
const helpers = {
    liftMaybe(maybe) {
        if (maybe.isJust()) {
            return Promise.resolve(maybe.extract());
        }
        throw Maybe_1.Nothing;
    },
    fromPromise(promise) {
        return promise.then(helpers.liftMaybe);
    }
};
class MaybeAsyncImpl {
    constructor(runPromise) {
        this.runPromise = runPromise;
        this[_a] = 'MaybeAsync';
        this['fantasy-land/map'] = this.map;
        this['fantasy-land/chain'] = this.chain;
        this['fantasy-land/ap'] = this.ap;
        this['fantasy-land/filter'] = this.filter;
        this['fantasy-land/extend'] = this.extend;
        this['fantasy-land/alt'] = this.alt;
    }
    orDefault(defaultValue) {
        return this.run().then((x) => x.orDefault(defaultValue));
    }
    join() {
        return (0, exports.MaybeAsync)(async (helpers) => {
            const maybe = await this.run();
            if (maybe.isJust()) {
                const nestedMaybe = await maybe.extract();
                return helpers.liftMaybe(nestedMaybe);
            }
            return helpers.liftMaybe(Maybe_1.Nothing);
        });
    }
    ap(maybeF) {
        return (0, exports.MaybeAsync)(async (helpers) => {
            const otherValue = await maybeF;
            if (otherValue.isJust()) {
                const thisValue = await this;
                if (thisValue.isJust()) {
                    return otherValue.extract()(thisValue.extract());
                }
                else {
                    return helpers.liftMaybe(Maybe_1.Nothing);
                }
            }
            return helpers.liftMaybe(Maybe_1.Nothing);
        });
    }
    alt(other) {
        return (0, exports.MaybeAsync)(async (helpers) => {
            const thisValue = await this;
            if (thisValue.isJust()) {
                return thisValue.extract();
            }
            else {
                const otherValue = await other;
                return helpers.liftMaybe(otherValue);
            }
        });
    }
    extend(f) {
        return (0, exports.MaybeAsync)(async (helpers) => {
            const maybe = await this.run();
            if (maybe.isJust()) {
                const v = exports.MaybeAsync.liftMaybe(maybe);
                return helpers.liftMaybe((0, Maybe_1.Just)(f(v)));
            }
            return helpers.liftMaybe(Maybe_1.Nothing);
        });
    }
    filter(pred) {
        return (0, exports.MaybeAsync)(async (helpers) => {
            const value = await this.run();
            return helpers.liftMaybe(value.filter(pred));
        });
    }
    async run() {
        try {
            return (0, Maybe_1.Just)(await this.runPromise(helpers));
        }
        catch (_b) {
            return Maybe_1.Nothing;
        }
    }
    map(f) {
        return (0, exports.MaybeAsync)((helpers) => this.runPromise(helpers).then(f));
    }
    chain(f) {
        return (0, exports.MaybeAsync)(async (helpers) => {
            const value = await this.runPromise(helpers);
            return helpers.fromPromise(f(value));
        });
    }
    toEitherAsync(error) {
        return (0, EitherAsync_1.EitherAsync)(async ({ liftEither }) => {
            const maybe = await this.run();
            return liftEither(maybe.toEither(error));
        });
    }
    ifJust(effect) {
        return (0, exports.MaybeAsync)(async (helpers) => {
            const maybe = await this.run();
            maybe.ifJust(effect);
            return helpers.liftMaybe(maybe);
        });
    }
    ifNothing(effect) {
        return (0, exports.MaybeAsync)(async (helpers) => {
            const maybe = await this.run();
            maybe.ifNothing(effect);
            return helpers.liftMaybe(maybe);
        });
    }
    void() {
        return this.map((_) => { });
    }
    caseOf(patterns) {
        return this.run().then((x) => x.caseOf(patterns));
    }
    finally(effect) {
        return (0, exports.MaybeAsync)(({ fromPromise }) => fromPromise(this.run().finally(effect)));
    }
    then(onfulfilled, onrejected) {
        return this.run().then(onfulfilled, onrejected);
    }
}
_a = Symbol.toStringTag;
exports.MaybeAsync = Object.assign((runPromise) => new MaybeAsyncImpl(runPromise), {
    catMaybes: (list) => Promise.all(list).then(Maybe_1.Maybe.catMaybes),
    fromPromise: (f) => (0, exports.MaybeAsync)(({ fromPromise: fP }) => fP(f())),
    liftMaybe: (maybe) => (0, exports.MaybeAsync)(({ liftMaybe }) => liftMaybe(maybe))
});
MaybeAsyncImpl.prototype.constructor = exports.MaybeAsync;
