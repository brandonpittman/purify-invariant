"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.List = void 0;
const Tuple_1 = require("./Tuple");
const Maybe_1 = require("./Maybe");
const Function_1 = require("./Function");
/** Returns Just the first element of an array or Nothing if there is none. If you don't want to work with a Maybe but still keep type safety, check out `NonEmptyList` */
const head = (list) => list.length > 0 ? (0, Maybe_1.Just)(list[0]) : Maybe_1.Nothing;
/** Returns Just the last element of an array or Nothing if there is none */
const last = (list) => list.length > 0 ? (0, Maybe_1.Just)(list[list.length - 1]) : Maybe_1.Nothing;
/** Returns all elements of an array except the first */
const tail = (list) => list.length > 0 ? (0, Maybe_1.Just)(list.slice(1)) : Maybe_1.Nothing;
/** Returns all elements of an array except the last */
const init = (list) => list.length > 0 ? (0, Maybe_1.Just)(list.slice(0, -1)) : Maybe_1.Nothing;
/** Returns a tuple of an array's head and tail */
const uncons = (list) => list.length > 0 ? (0, Maybe_1.Just)((0, Tuple_1.Tuple)(list[0], list.slice(1))) : Maybe_1.Nothing;
/* Returns the sum of all numbers inside an array */
const sum = (list) => list.reduce((acc, x) => acc + x, 0);
function find(f, list) {
    switch (arguments.length) {
        case 1:
            return (list) => find(f, list);
        default:
            return Maybe_1.Maybe.fromNullable(list.find(f));
    }
}
function findIndex(f, list) {
    switch (arguments.length) {
        case 1:
            return (list) => findIndex(f, list);
        default:
            return Maybe_1.Maybe.fromPredicate((x) => x !== -1, list.findIndex(f));
    }
}
function at(index, list) {
    switch (arguments.length) {
        case 1:
            return (list) => at(index, list);
        default:
            return list[index] === undefined ? Maybe_1.Nothing : (0, Maybe_1.Just)(list[index]);
    }
}
function sort(compare, list) {
    switch (arguments.length) {
        case 1:
            return (list) => sort(compare, list);
        default:
            return [...list].sort((x, y) => (0, Function_1.orderToNumber)(compare(x, y)));
    }
}
exports.List = {
    init,
    uncons,
    at,
    head,
    last,
    tail,
    find,
    findIndex,
    sum,
    sort
};
